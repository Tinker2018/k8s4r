package agent

import (
	"context"
	"os"
	"path/filepath"
	"testing"
	"time"

	"github.com/hashicorp/go-hclog"
	robotv1alpha1 "github.com/hxndghxndg/k8s4r/api/v1alpha1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/types"
)

// ============================================================================
// IMPORTANT: All tests in this file require root privileges to run
// ============================================================================
//
// These tests use Nomad executor with cgroup isolation, which requires
// root access to create and manage cgroups.
//
// Run with sudo:
//   sudo -E go test -v -run TestTaskGroupExecutor ./pkg/agent
//
// The -E flag preserves environment variables like GOPROXY, GOPATH, etc.
//
// ============================================================================

// TestTaskGroupExecutor_SimpleExecution 测试简单的 TaskGroup 执行
func TestTaskGroupExecutor_SimpleExecution(t *testing.T) {
	// 检查是否以 root 运行
	if os.Geteuid() != 0 {
		t.Skip("This test requires root privileges (run with sudo)")
	}

	// 创建临时工作目录
	workDir := filepath.Join(os.TempDir(), "k8s4r-test-taskgroup-simple")
	defer os.RemoveAll(workDir)

	if err := os.MkdirAll(workDir, 0755); err != nil {
		t.Fatalf("Failed to create work dir: %v", err)
	}

	// 创建 logger
	logger := hclog.New(&hclog.LoggerOptions{
		Name:   "test-taskgroup-executor",
		Level:  hclog.Debug,
		Output: os.Stdout,
	})

	// 创建测试 TaskGroup
	taskGroup := &robotv1alpha1.TaskGroup{
		ObjectMeta: metav1.ObjectMeta{
			Name:      "test-taskgroup-simple",
			Namespace: "default",
			UID:       types.UID("test-taskgroup-uid-12345"),
		},
		Spec: robotv1alpha1.TaskGroupSpec{
			// InitTask: 创建测试目录
			InitTasks: []robotv1alpha1.TaskDefinition{
				{
					Name:   "setup-workspace",
					Driver: "exec",
					Daemon: false,
					Config: robotv1alpha1.TaskDriverConfig{
						ExecConfig: &robotv1alpha1.ExecDriverConfig{
							Command: "/usr/bin/bash",
							Args: []string{
								"-c",
								`
								echo "=== Setting up workspace ==="
								mkdir -p /tmp/k8s4r-taskgroup-test/data
								echo "Workspace created at /tmp/k8s4r-taskgroup-test"
								echo "test-data-$(date +%s)" > /tmp/k8s4r-taskgroup-test/data/test.txt
								echo "=== Setup completed ==="
								`,
							},
						},
					},
				},
			},
			// 主 Task: 验证 InitTask 完成
			Tasks: []robotv1alpha1.TaskDefinition{
				{
					Name:   "verify-and-run",
					Driver: "exec",
					Config: robotv1alpha1.TaskDriverConfig{
						ExecConfig: &robotv1alpha1.ExecDriverConfig{
							Command: "/usr/bin/bash",
							Args: []string{
								"-c",
								`
								echo "=== Main task starting ==="
								
								# 验证 InitTask 创建的目录和文件
								if [ -d /tmp/k8s4r-taskgroup-test/data ]; then
									echo "✓ Workspace directory exists"
								else
									echo "✗ Workspace directory not found"
									exit 1
								fi
								
								if [ -f /tmp/k8s4r-taskgroup-test/data/test.txt ]; then
									echo "✓ Test file exists"
									echo "  Content: $(cat /tmp/k8s4r-taskgroup-test/data/test.txt)"
								else
									echo "✗ Test file not found"
									exit 1
								fi
								
								# 模拟一些工作
								echo "=== Performing work ==="
								for i in {1..3}; do
									echo "  Step $i: Processing..."
									sleep 1
								done
								
								echo "=== Main task completed successfully ==="
								`,
							},
						},
					},
					Env: map[string]string{
						"TASK_ENV": "test",
					},
				},
			},
		},
		Status: robotv1alpha1.TaskGroupStatus{
			State: "pending",
		},
	}

	// 创建 TaskGroupExecutor
	executor := NewTaskGroupExecutor(taskGroup, "test-robot-001", workDir, logger)

	// 创建上下文（设置 30 秒超时）
	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()

	// 执行 TaskGroup
	t.Log("Starting TaskGroup execution...")
	err := executor.Execute(ctx)

	// 验证结果
	if err != nil {
		t.Fatalf("TaskGroup execution failed: %v", err)
	}

	t.Log("TaskGroup execution completed successfully")

	// 验证 InitTask 创建的文件
	testFilePath := "/tmp/k8s4r-taskgroup-test/data/test.txt"
	if _, err := os.Stat(testFilePath); os.IsNotExist(err) {
		t.Errorf("InitTask did not create expected file: %s", testFilePath)
	} else {
		t.Logf("✓ InitTask successfully created file: %s", testFilePath)
	}

	// 清理测试文件
	os.RemoveAll("/tmp/k8s4r-taskgroup-test")
}

// TestTaskGroupExecutor_WithDaemonInitTask 测试带守护进程 InitTask 的 TaskGroup
func TestTaskGroupExecutor_WithDaemonInitTask(t *testing.T) {
	// 检查是否以 root 运行
	if os.Geteuid() != 0 {
		t.Skip("This test requires root privileges (run with sudo)")
	}

	// 创建临时工作目录
	workDir := filepath.Join(os.TempDir(), "k8s4r-test-taskgroup-daemon")
	defer os.RemoveAll(workDir)

	if err := os.MkdirAll(workDir, 0755); err != nil {
		t.Fatalf("Failed to create work dir: %v", err)
	}

	// 创建 logger
	logger := hclog.New(&hclog.LoggerOptions{
		Name:   "test-taskgroup-daemon",
		Level:  hclog.Debug,
		Output: os.Stdout,
	})

	// 创建测试 TaskGroup
	taskGroup := &robotv1alpha1.TaskGroup{
		ObjectMeta: metav1.ObjectMeta{
			Name:      "test-taskgroup-daemon",
			Namespace: "default",
			UID:       types.UID("test-taskgroup-daemon-uid-67890"),
		},
		Spec: robotv1alpha1.TaskGroupSpec{
			InitTasks: []robotv1alpha1.TaskDefinition{
				// 守护进程 InitTask
				{
					Name:   "background-service",
					Driver: "exec",
					Daemon: true, // 守护进程
					Config: robotv1alpha1.TaskDriverConfig{
						ExecConfig: &robotv1alpha1.ExecDriverConfig{
							Command: "/usr/bin/bash",
							Args: []string{
								"-c",
								`
								echo "=== Background service starting ==="
								echo "Service PID: $$"
								touch /tmp/k8s4r-daemon-test.pid
								echo $$ > /tmp/k8s4r-daemon-test.pid
								# 模拟后台服务
								while true; do
									echo "[$(date)] Background service is running..."
									sleep 2
								done
								`,
							},
						},
					},
				},
				// 等待守护进程启动
				{
					Name:   "wait-service",
					Driver: "exec",
					Daemon: false,
					Config: robotv1alpha1.TaskDriverConfig{
						ExecConfig: &robotv1alpha1.ExecDriverConfig{
							Command: "/usr/bin/bash",
							Args: []string{
								"-c",
								`
								echo "Waiting for background service..."
								for i in {1..10}; do
									if [ -f /tmp/k8s4r-daemon-test.pid ]; then
										echo "✓ Background service started"
										exit 0
									fi
									echo "Attempt $i: waiting..."
									sleep 1
								done
								echo "Timeout waiting for service"
								exit 1
								`,
							},
						},
					},
				},
			},
			Tasks: []robotv1alpha1.TaskDefinition{
				{
					Name:   "main-task",
					Driver: "exec",
					Config: robotv1alpha1.TaskDriverConfig{
						ExecConfig: &robotv1alpha1.ExecDriverConfig{
							Command: "/usr/bin/bash",
							Args: []string{
								"-c",
								`
								echo "=== Main task starting ==="
								if [ -f /tmp/k8s4r-daemon-test.pid ]; then
									echo "✓ Background service is running"
									echo "  PID: $(cat /tmp/k8s4r-daemon-test.pid)"
								else
									echo "✗ Background service not found"
									exit 1
								fi
								echo "=== Main task completed ==="
								`,
							},
						},
					},
				},
			},
		},
	}

	// 创建 TaskGroupExecutor
	executor := NewTaskGroupExecutor(taskGroup, "test-robot-002", workDir, logger)

	// 创建上下文
	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()

	// 执行 TaskGroup
	t.Log("Starting TaskGroup execution with daemon InitTask...")
	err := executor.Execute(ctx)

	// 验证结果
	if err != nil {
		t.Fatalf("TaskGroup execution failed: %v", err)
	}

	t.Log("TaskGroup execution completed successfully")

	// 清理守护进程
	executor.Cleanup(context.Background())

	// 验证守护进程已被清理
	time.Sleep(1 * time.Second)
	if _, err := os.Stat("/tmp/k8s4r-daemon-test.pid"); err == nil {
		t.Log("Cleaning up daemon test PID file")
		os.Remove("/tmp/k8s4r-daemon-test.pid")
	}
}

// TestTaskGroupExecutor_TaskIsolation 测试不同 TaskGroup 的隔离性
func TestTaskGroupExecutor_TaskIsolation(t *testing.T) {
	// 检查是否以 root 运行
	if os.Geteuid() != 0 {
		t.Skip("This test requires root privileges (run with sudo)")
	}

	// 创建临时工作目录
	workDir1 := filepath.Join(os.TempDir(), "k8s4r-test-tg1")
	workDir2 := filepath.Join(os.TempDir(), "k8s4r-test-tg2")
	defer func() {
		os.RemoveAll(workDir1)
		os.RemoveAll(workDir2)
	}()

	for _, dir := range []string{workDir1, workDir2} {
		if err := os.MkdirAll(dir, 0755); err != nil {
			t.Fatalf("Failed to create work dir: %v", err)
		}
	}

	logger := hclog.New(&hclog.LoggerOptions{
		Name:   "test-isolation",
		Level:  hclog.Info,
		Output: os.Stdout,
	})

	// 创建两个 TaskGroup
	createTaskGroup := func(name, uid string) *robotv1alpha1.TaskGroup {
		return &robotv1alpha1.TaskGroup{
			ObjectMeta: metav1.ObjectMeta{
				Name:      name,
				Namespace: "default",
				UID:       types.UID(uid),
			},
			Spec: robotv1alpha1.TaskGroupSpec{
				Tasks: []robotv1alpha1.TaskDefinition{
					{
						Name:   "task-1",
						Driver: "exec",
						Config: robotv1alpha1.TaskDriverConfig{
							ExecConfig: &robotv1alpha1.ExecDriverConfig{
								Command: "/usr/bin/bash",
								Args: []string{
									"-c",
									`echo "Task from ` + name + `" && sleep 1`,
								},
							},
						},
					},
				},
			},
		}
	}

	tg1 := createTaskGroup("taskgroup-1", "tg-uid-1")
	tg2 := createTaskGroup("taskgroup-2", "tg-uid-2")

	executor1 := NewTaskGroupExecutor(tg1, "test-robot", workDir1, logger)
	executor2 := NewTaskGroupExecutor(tg2, "test-robot", workDir2, logger)

	ctx := context.Background()

	// 并发执行两个 TaskGroup
	done1 := make(chan error, 1)
	done2 := make(chan error, 1)

	go func() {
		done1 <- executor1.Execute(ctx)
	}()

	go func() {
		done2 <- executor2.Execute(ctx)
	}()

	// 等待两个都完成
	err1 := <-done1
	err2 := <-done2

	if err1 != nil {
		t.Errorf("TaskGroup 1 failed: %v", err1)
	}
	if err2 != nil {
		t.Errorf("TaskGroup 2 failed: %v", err2)
	}

	// 验证每个 TaskGroupExecutor 有独立的 TaskExecutor
	tasks1 := executor1.GetAllTasks()
	tasks2 := executor2.GetAllTasks()

	t.Logf("TaskGroup 1 has %d tasks", len(tasks1))
	t.Logf("TaskGroup 2 has %d tasks", len(tasks2))

	if len(tasks1) != 1 || len(tasks2) != 1 {
		t.Error("Each TaskGroup should have exactly 1 task")
	}

	t.Log("✓ TaskGroup isolation verified: each has independent TaskExecutor")
}
