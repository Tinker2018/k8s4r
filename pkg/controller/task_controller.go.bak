package controller

import (
	"context"
	"encoding/json"
	"fmt"
	"time"

	mqtt "github.com/eclipse/paho.mqtt.golang"
	"k8s.io/apimachinery/pkg/api/errors"
	"k8s.io/apimachinery/pkg/runtime"
	ctrl "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/log"

	robotv1alpha1 "github.com/hxndg/k8s4r/api/v1alpha1"
)

// TaskReconciler reconciles a Task object
type TaskReconciler struct {
	client.Client
	Scheme     *runtime.Scheme
	MQTTClient mqtt.Client
}

// TaskMessage MQTT 任务消息
type TaskMessage struct {
	Action string              `json:"action"` // create, update, delete
	Task   *robotv1alpha1.Task `json:"task"`
}

// TaskStatusMessage MQTT 任务状态上报消息
type TaskStatusMessage struct {
	TaskID    string    `json:"taskId"`
	RobotID   string    `json:"robotId"`
	State     string    `json:"state"`
	ExitCode  int       `json:"exitCode"`
	Message   string    `json:"message"`
	UpdatedAt time.Time `json:"updatedAt"`
}

//+kubebuilder:rbac:groups=robot.k8s4r.io,resources=tasks,verbs=get;list;watch;create;update;patch;delete
//+kubebuilder:rbac:groups=robot.k8s4r.io,resources=tasks/status,verbs=get;update;patch
//+kubebuilder:rbac:groups=robot.k8s4r.io,resources=tasks/finalizers,verbs=update

// Reconcile is part of the main kubernetes reconciliation loop
func (r *TaskReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {
	logger := log.FromContext(ctx)

	// 获取 Task 资源
	task := &robotv1alpha1.Task{}
	err := r.Get(ctx, req.NamespacedName, task)
	if err != nil {
		if errors.IsNotFound(err) {
			// Task 已删除，无需处理
			logger.Info("Task resource not found, ignoring")
			return ctrl.Result{}, nil
		}
		logger.Error(err, "Failed to get Task")
		return ctrl.Result{}, err
	}

	logger.Info("Reconciling Task", "task", task.Name, "driver", task.Spec.Driver)

	// 根据 Task 状态处理
	if task.DeletionTimestamp != nil {
		// Task 正在被删除
		return r.handleDeletion(ctx, task)
	}

	// 处理新创建或更新的 Task
	return r.handleCreateOrUpdate(ctx, task)
}

// handleCreateOrUpdate 处理 Task 创建或更新
func (r *TaskReconciler) handleCreateOrUpdate(ctx context.Context, task *robotv1alpha1.Task) (ctrl.Result, error) {
	logger := log.FromContext(ctx)

	// 如果状态为空，初始化为 Pending
	if task.Status.State == "" {
		task.Status.State = robotv1alpha1.TaskStatePending
		task.Status.Message = "Task is pending for scheduling"
		if err := r.Status().Update(ctx, task); err != nil {
			logger.Error(err, "Failed to update Task status")
			return ctrl.Result{}, err
		}
	}

	// 获取目标 Robot
	robot, err := r.getTargetRobot(ctx, task)
	if err != nil {
		logger.Error(err, "Failed to get target robot")
		task.Status.State = robotv1alpha1.TaskStateDead
		task.Status.Message = fmt.Sprintf("Failed to find target robot: %v", err)
		task.Status.Reason = "NoRobotAvailable"
		_ = r.Status().Update(ctx, task)
		return ctrl.Result{RequeueAfter: 30 * time.Second}, nil
	}

	// 更新状态为 Running
	if task.Status.State == robotv1alpha1.TaskStatePending {
		task.Status.State = robotv1alpha1.TaskStateRunning
		task.Status.Message = fmt.Sprintf("Task dispatched to robot %s", robot.Name)
		task.Status.Reason = "Dispatched"
		// 使用 Annotations 记录目标 Robot
		if task.Annotations == nil {
			task.Annotations = make(map[string]string)
		}
		task.Annotations["k8s4r.io/target-robot"] = robot.Name

		if err := r.Update(ctx, task); err != nil {
			logger.Error(err, "Failed to update Task annotations")
			return ctrl.Result{}, err
		}
		if err := r.Status().Update(ctx, task); err != nil {
			logger.Error(err, "Failed to update Task status")
			return ctrl.Result{}, err
		}
	}

	// 通过 MQTT 分发任务到机器人
	if err := r.dispatchTaskToRobot(ctx, task, robot); err != nil {
		logger.Error(err, "Failed to dispatch task to robot")
		return ctrl.Result{RequeueAfter: 10 * time.Second}, err
	}

	logger.Info("Task dispatched successfully", "task", task.Name, "robot", robot.Name)

	return ctrl.Result{}, nil
}

// handleDeletion 处理 Task 删除
func (r *TaskReconciler) handleDeletion(ctx context.Context, task *robotv1alpha1.Task) (ctrl.Result, error) {
	logger := log.FromContext(ctx)

	logger.Info("Handling Task deletion", "task", task.Name)

	// 从 Annotations 获取目标 Robot
	if task.Annotations != nil {
		if robotName, ok := task.Annotations["k8s4r.io/target-robot"]; ok && robotName != "" {
			robot := &robotv1alpha1.Robot{}
			if err := r.Get(ctx, client.ObjectKey{
				Namespace: task.Namespace,
				Name:      robotName,
			}, robot); err == nil {
				// 发送删除消息到机器人
				_ = r.sendDeleteTaskMessage(task, robot)
			}
		}
	}

	return ctrl.Result{}, nil
}

// getTargetRobot 获取目标机器人
func (r *TaskReconciler) getTargetRobot(ctx context.Context, task *robotv1alpha1.Task) (*robotv1alpha1.Robot, error) {
	// 简单实现：选择第一个 Ready 的机器人
	// 后续可以根据约束条件、资源需求等进行智能调度

	robotList := &robotv1alpha1.RobotList{}
	if err := r.List(ctx, robotList, client.InNamespace(task.Namespace)); err != nil {
		return nil, err
	}

	for i := range robotList.Items {
		robot := &robotList.Items[i]
		if robot.Status.Phase == robotv1alpha1.RobotPhaseOnline {
			// TODO: 检查约束条件和资源
			return robot, nil
		}
	}

	return nil, fmt.Errorf("no ready robot found")
}

// dispatchTaskToRobot 通过 MQTT 将任务分发到机器人
func (r *TaskReconciler) dispatchTaskToRobot(ctx context.Context, task *robotv1alpha1.Task, robot *robotv1alpha1.Robot) error {
	logger := log.FromContext(ctx)

	// 构造任务消息
	msg := TaskMessage{
		Action: "create",
		Task:   task,
	}

	payload, err := json.Marshal(msg)
	if err != nil {
		return fmt.Errorf("failed to marshal task message: %v", err)
	}

	// 发送到机器人的任务 topic
	topic := fmt.Sprintf("robots/%s/tasks", robot.Name)

	logger.Info("Publishing task to MQTT", "topic", topic, "task", task.Name)

	token := r.MQTTClient.Publish(topic, 1, false, payload)
	token.Wait()
	if err := token.Error(); err != nil {
		return fmt.Errorf("failed to publish task to MQTT: %v", err)
	}

	return nil
}

// sendDeleteTaskMessage 发送删除任务消息
func (r *TaskReconciler) sendDeleteTaskMessage(task *robotv1alpha1.Task, robot *robotv1alpha1.Robot) error {
	msg := TaskMessage{
		Action: "delete",
		Task:   task,
	}

	payload, err := json.Marshal(msg)
	if err != nil {
		return err
	}

	topic := fmt.Sprintf("robots/%s/tasks", robot.Name)
	token := r.MQTTClient.Publish(topic, 1, false, payload)
	token.Wait()
	return token.Error()
}

// SetupWithManager sets up the controller with the Manager.
func (r *TaskReconciler) SetupWithManager(mgr ctrl.Manager) error {
	return ctrl.NewControllerManagedBy(mgr).
		For(&robotv1alpha1.Task{}).
		Complete(r)
}

// SetupTaskStatusListener 设置 MQTT 任务状态监听
func (r *TaskReconciler) SetupTaskStatusListener(ctx context.Context) error {
	logger := log.FromContext(ctx)

	// 订阅所有机器人的任务状态上报 topic
	topic := "robots/+/task/status"

	logger.Info("Subscribing to task status updates", "topic", topic)

	token := r.MQTTClient.Subscribe(topic, 1, func(client mqtt.Client, msg mqtt.Message) {
		r.handleTaskStatusUpdate(ctx, msg)
	})
	token.Wait()
	if err := token.Error(); err != nil {
		return fmt.Errorf("failed to subscribe to task status topic: %v", err)
	}

	return nil
}

// handleTaskStatusUpdate 处理任务状态更新
func (r *TaskReconciler) handleTaskStatusUpdate(ctx context.Context, msg mqtt.Message) {
	logger := log.FromContext(ctx)

	var statusMsg TaskStatusMessage
	if err := json.Unmarshal(msg.Payload(), &statusMsg); err != nil {
		logger.Error(err, "Failed to unmarshal task status message")
		return
	}

	logger.Info("Received task status update",
		"taskId", statusMsg.TaskID,
		"robotId", statusMsg.RobotID,
		"state", statusMsg.State)

	// 更新 Task 状态
	task := &robotv1alpha1.Task{}
	// TaskID 是 Task 的 UID
	// 需要通过列表查找对应的 Task
	taskList := &robotv1alpha1.TaskList{}
	if err := r.List(ctx, taskList); err != nil {
		logger.Error(err, "Failed to list tasks")
		return
	}

	for i := range taskList.Items {
		t := &taskList.Items[i]
		if string(t.UID) == statusMsg.TaskID {
			task = t
			break
		}
	}

	if task.Name == "" {
		logger.Error(nil, "Task not found", "taskId", statusMsg.TaskID)
		return
	}

	// 更新状态
	task.Status.State = robotv1alpha1.TaskState(statusMsg.State)
	task.Status.Message = statusMsg.Message
	exitCode := int32(statusMsg.ExitCode)
	task.Status.ExitCode = &exitCode

	if err := r.Status().Update(ctx, task); err != nil {
		logger.Error(err, "Failed to update task status")
	}
}
